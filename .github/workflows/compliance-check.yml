name: SOC2 Compliance Check

on:
  workflow_call:
    inputs:
      pr_body:
        description: "Pull request body text"
        required: true
        type: string
      pr_title:
        description: "Pull request title"
        required: false
        type: string
        default: ""
      pr_author:
        description: "Pull request author login"
        required: false
        type: string
        default: ""
      pr_number:
        description: "Pull request number"
        required: true
        type: string
      repo:
        description: "Repository being checked (owner/name)"
        required: true
        type: string
      base_branch:
        description: "Base branch to diff against"
        required: false
        type: string
        default: "main"
      ticket_pattern:
        description: "Regex pattern for ticket IDs (e.g., 'PROJ-[0-9]+')"
        required: true
        type: string
      issues_path:
        description: "Path to issue requirement files"
        required: false
        type: string
        default: "issues"
      specs_path:
        description: "Path to technical spec files"
        required: false
        type: string
        default: "specs"
      linear_team_id:
        description: "Linear team ID (optional, for Linear integration)"
        required: false
        type: string
      required_reviewers:
        description: "Comma-separated required review bots (e.g., 'coderabbit,aikido,greptile')"
        required: false
        type: string
        default: ""
      confidence_threshold:
        description: "Minimum confidence % to pass (0-100)"
        required: false
        type: number
        default: 70
      pr_labels:
        description: "Comma-separated PR labels (used for compliance:exempt detection)"
        required: false
        type: string
        default: ""
      test_exclude_paths:
        description: "Comma-separated path prefixes to exclude from test coverage checks (e.g., 'xd/,firmware/')"
        required: false
        type: string
        default: ""
    secrets:
      GEMINI_API_KEY:
        required: true
      LINEAR_API_KEY:
        required: false
      REPO_TOKEN:
        required: true
    outputs:
      compliant:
        description: "Whether the PR is compliant"
        value: ${{ jobs.compliance-audit.outputs.compliant }}
      report:
        description: "Compliance report JSON"
        value: ${{ jobs.compliance-audit.outputs.report }}

jobs:
  compliance-audit:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      compliant: ${{ steps.check.outputs.compliant }}
      report: ${{ steps.check.outputs.report }}

    steps:
      - name: Checkout compliance tools
        uses: actions/checkout@v4
        with:
          repository: dorkalev/soc2-compliance

      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          token: ${{ secrets.REPO_TOKEN }}
          path: ./target
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}

      - name: Fetch base branch
        working-directory: ./target
        run: git fetch origin ${{ inputs.base_branch }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: pip install httpx google-genai

      - name: Run compliance agent
        id: check
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          GITHUB_TOKEN: ${{ secrets.REPO_TOKEN }}
          REPO_TOKEN: ${{ secrets.REPO_TOKEN }}
          PR_BODY: ${{ inputs.pr_body }}
          PR_TITLE: ${{ inputs.pr_title }}
          PR_AUTHOR: ${{ inputs.pr_author }}
          PR_NUMBER: ${{ inputs.pr_number }}
          REPO: ${{ inputs.repo }}
          TARGET_REPO: ./target
          BASE_BRANCH: ${{ inputs.base_branch }}
          TICKET_PATTERN: ${{ inputs.ticket_pattern }}
          ISSUES_PATH: ${{ inputs.issues_path }}
          SPECS_PATH: ${{ inputs.specs_path }}
          LINEAR_TEAM_ID: ${{ inputs.linear_team_id }}
          REQUIRED_REVIEWERS: ${{ inputs.required_reviewers }}
          CONFIDENCE_THRESHOLD: ${{ inputs.confidence_threshold }}
          PR_LABELS: ${{ inputs.pr_labels }}
          TEST_EXCLUDE_PATHS: ${{ inputs.test_exclude_paths }}
          GITHUB_RUN_ID: ${{ github.run_id }}
          COMMIT_SHA: ${{ github.event.pull_request.head.sha || github.sha }}
        run: |
          set +e
          python scripts/verify_compliance.py > compliance_report.json 2>compliance_stderr.log
          EXIT_CODE=$?
          set -e

          if [ -s compliance_stderr.log ]; then
            echo "::group::Agent stderr"
            cat compliance_stderr.log
            echo "::endgroup::"
          fi

          # Fallback if script crashed
          if [ $EXIT_CODE -ne 0 ] || [ ! -s compliance_report.json ]; then
            echo "Agent failed with exit code $EXIT_CODE"
            echo '{"compliant": false, "summary": "Compliance agent crashed", "issues": ["Check workflow logs"], "tickets_found": []}' > compliance_report.json
          fi

          # Validate JSON
          if ! jq -e . compliance_report.json > /dev/null 2>&1; then
            echo "Invalid JSON output:"
            cat compliance_report.json
            echo '{"compliant": false, "summary": "Agent produced invalid JSON", "issues": ["Check workflow logs"], "tickets_found": []}' > compliance_report.json
          fi

          COMPLIANT=$(jq -r '.compliant' compliance_report.json)
          echo "compliant=$COMPLIANT" >> $GITHUB_OUTPUT

          REPORT=$(cat compliance_report.json | jq -c .)
          echo "report=$REPORT" >> $GITHUB_OUTPUT

      # Fallback comment â€” only if the agent didn't manage to post one
      - name: Post fallback comment
        if: failure()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.REPO_TOKEN }}
          script: |
            const fs = require('fs');
            let report;
            try {
              report = JSON.parse(fs.readFileSync('compliance_report.json', 'utf8'));
            } catch {
              report = { compliant: false, summary: 'Agent crashed before reporting', issues: ['Check workflow logs'] };
            }

            const MARKER = '<!-- soc2-compliance-bot -->';
            const sha = '${{ github.event.pull_request.head.sha || github.sha }}'.substring(0, 7);
            const runId = '${{ github.run_id }}';
            let body = `${MARKER}\n## âŒ SOC2 Compliance: Failed\n\n`;
            body += `**${report.summary || 'Unknown error'}**\n\n`;
            if (report.issues?.length) {
              report.issues.forEach(i => body += `- ${i}\n`);
            }
            body += `\n---\n\n## ðŸ”§ How to Fix\n\nRun this command in Claude Code:\n\n\`\`\`\n/forge:fix-compliance\n\`\`\`\n\n`;
            body += `---\n<sub>[soc2-compliance](https://github.com/dorkalev/soc2-compliance) Â· commit ${sha} Â· [run ${runId}](https://github.com/${{ inputs.repo }}/actions/runs/${runId})</sub>`;

            const [owner, repo] = '${{ inputs.repo }}'.split('/');
            const issue_number = parseInt('${{ inputs.pr_number }}');

            // Find existing compliance comment to update
            let existingId = null;
            const comments = await github.rest.issues.listComments({ owner, repo, issue_number, per_page: 100 });
            for (const c of comments.data) {
              if (c.body && c.body.includes(MARKER)) {
                existingId = c.id;
                break;
              }
            }

            if (existingId) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: existingId, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number, body });
            }

      - name: Upload compliance report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: compliance-report-${{ inputs.pr_number }}
          path: compliance_report.json
          retention-days: 90

      - name: Fail if not compliant
        if: steps.check.outputs.compliant == 'false'
        run: |
          echo ""
          echo "============================================"
          echo "  SOC2 Compliance Check FAILED"
          echo "============================================"
          echo ""
          SUMMARY=$(jq -r '.summary // "No summary"' compliance_report.json 2>/dev/null)
          echo "::error::$SUMMARY"
          echo ""

          for field in issues invalid_tickets unspecced_changes missing_documentation untested_files unresolved_reviews missing_reviewers spec_issues; do
            COUNT=$(jq -r ".$field | length" compliance_report.json 2>/dev/null || echo "0")
            if [ "$COUNT" != "0" ] && [ "$COUNT" != "null" ]; then
              LABEL=$(echo "$field" | tr '_' ' ')
              echo "::group::$LABEL ($COUNT)"
              jq -r ".$field[]" compliance_report.json 2>/dev/null | while IFS= read -r item; do
                echo "  - $item"
              done
              echo "::endgroup::"
            fi
          done

          exit 1

name: SOC2 Compliance Check

on:
  workflow_call:
    inputs:
      pr_body:
        description: "Pull request body text"
        required: true
        type: string
      pr_number:
        description: "Pull request number"
        required: true
        type: string
      repo:
        description: "Repository being checked (owner/name)"
        required: true
        type: string
      base_branch:
        description: "Base branch to diff against"
        required: false
        type: string
        default: "main"
      ticket_pattern:
        description: "Regex pattern for ticket IDs (e.g., 'PROJ-[0-9]+')"
        required: true
        type: string
      issues_path:
        description: "Path to issue requirement files"
        required: false
        type: string
        default: "issues"
      specs_path:
        description: "Path to technical spec files"
        required: false
        type: string
        default: "specs"
      linear_team_id:
        description: "Linear team ID (optional, for Linear integration)"
        required: false
        type: string
      fail_on_unspecced:
        description: "Fail if changes are not covered by specs"
        required: false
        type: boolean
        default: true
      fail_on_missing_ticket:
        description: "Fail if no ticket is referenced in PR"
        required: false
        type: boolean
        default: true
    secrets:
      GEMINI_API_KEY:
        required: true
      LINEAR_API_KEY:
        required: false
      REPO_TOKEN:
        required: true
    outputs:
      compliant:
        description: "Whether the PR is compliant"
        value: ${{ jobs.tickets-and-specs.outputs.compliant }}
      report:
        description: "Compliance report JSON"
        value: ${{ jobs.tickets-and-specs.outputs.report }}

jobs:
  tickets-and-specs:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    outputs:
      compliant: ${{ steps.check.outputs.compliant }}
      report: ${{ steps.check.outputs.report }}

    steps:
      - name: Checkout compliance tools
        uses: actions/checkout@v4
        with:
          repository: dorkalev/soc2-compliance

      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          token: ${{ secrets.REPO_TOKEN }}
          path: ./target
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}

      - name: Fetch base branch
        working-directory: ./target
        run: git fetch origin ${{ inputs.base_branch }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: pip install httpx google-genai

      - name: Run compliance check
        id: check
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          PR_BODY: ${{ inputs.pr_body }}
          PR_NUMBER: ${{ inputs.pr_number }}
          TARGET_REPO: ./target
          BASE_BRANCH: ${{ inputs.base_branch }}
          TICKET_PATTERN: ${{ inputs.ticket_pattern }}
          ISSUES_PATH: ${{ inputs.issues_path }}
          SPECS_PATH: ${{ inputs.specs_path }}
          LINEAR_TEAM_ID: ${{ inputs.linear_team_id }}
          FAIL_ON_UNSPECCED: ${{ inputs.fail_on_unspecced }}
          FAIL_ON_MISSING_TICKET: ${{ inputs.fail_on_missing_ticket }}
        run: |
          # Run compliance check, capturing both stdout and exit code
          set +e
          python scripts/verify_compliance.py > compliance_report.json 2>&1
          EXIT_CODE=$?
          set -e

          # If script failed or output is empty, create error report
          if [ $EXIT_CODE -ne 0 ] || [ ! -s compliance_report.json ]; then
            echo "Script failed with exit code $EXIT_CODE"
            cat compliance_report.json || true
            echo '{"compliant": false, "summary": "Compliance check script failed", "issues": ["Script error - check workflow logs"], "tickets_found": []}' > compliance_report.json
          fi

          # Validate JSON
          if ! jq -e . compliance_report.json > /dev/null 2>&1; then
            echo "Invalid JSON in compliance_report.json:"
            cat compliance_report.json
            echo '{"compliant": false, "summary": "Invalid JSON output from compliance script", "issues": ["Script produced invalid JSON"], "tickets_found": []}' > compliance_report.json
          fi

          # Extract results for outputs
          COMPLIANT=$(jq -r '.compliant' compliance_report.json)
          echo "compliant=$COMPLIANT" >> $GITHUB_OUTPUT

          # Store full report (escape for GitHub Actions)
          REPORT=$(cat compliance_report.json | jq -c .)
          echo "report=$REPORT" >> $GITHUB_OUTPUT

      - name: Post comment to PR
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.REPO_TOKEN }}
          script: |
            const fs = require('fs');
            let report;
            try {
              const content = fs.readFileSync('compliance_report.json', 'utf8');
              if (!content || content.trim() === '') {
                throw new Error('compliance_report.json is empty');
              }
              report = JSON.parse(content);
            } catch (e) {
              console.error('Failed to parse compliance_report.json:', e.message);
              report = {
                compliant: false,
                summary: 'Failed to parse compliance report: ' + e.message,
                issues: ['Check workflow logs for details'],
                tickets_found: []
              };
            }

            const icon = report.compliant ? 'âœ…' : 'âŒ';
            const status = report.compliant ? 'Passed' : 'Failed';
            const primaryTicket = report.tickets_found?.[0] || 'TICKET-XXX';

            let body = `## ${icon} SOC2 Compliance: ${status}\n\n`;

            // Passed - keep it short
            if (report.compliant) {
              body += `All code changes are documented and traceable to Linear tickets.\n\n`;
              if (report.tickets_found?.length > 0) {
                body += `**Tickets:** ${report.tickets_found.join(', ')}\n\n`;
              }
              body += `---\n<sub>Generated by [soc2-compliance](https://github.com/dorkalev/soc2-compliance)</sub>`;
            } else {
              // Failed - provide actionable guidance
              body += `### What Failed\n\n`;

              // Collect all issues
              const problems = [];

              // Always show the summary as the first problem if present
              if (report.summary) {
                problems.push(`**${report.summary}**`);
              }

              if (report.unspecced_changes?.length > 0) {
                problems.push(`**Code not covered by tickets** - Changes found that don't match any listed ticket`);
              }
              if (report.invalid_tickets?.length > 0) {
                problems.push(`**Invalid tickets** - ${report.invalid_tickets.join(', ')} not found in Linear`);
              }
              if (report.unimplemented_tickets?.length > 0) {
                problems.push(`**Ghost tickets** - ${report.unimplemented_tickets.join(', ')} listed but no code changes`);
              }
              if (report.merge_commit_tickets?.length > 0) {
                problems.push(`**Inherited tickets** - ${report.merge_commit_tickets.join(', ')} came from merge commits`);
              }

              // Show any additional issues from the report not already covered
              if (report.issues?.length > 0) {
                for (const issue of report.issues) {
                  if (!problems.some(p => p.includes(issue))) {
                    problems.push(issue);
                  }
                }
              }

              problems.forEach(p => body += `- ${p}\n`);
              body += '\n';

              // THE FIX - one command
              body += `---\n\n`;
              body += `## ðŸ”§ How to Fix\n\n`;
              body += `Run this command in Claude Code:\n\n`;
              body += `\`\`\`\n/forge:fix-compliance\n\`\`\`\n\n`;
              body += `This will ensure all code changes are covered by tickets.\n\n`;

              // Additional context for specific issues
              if (report.merge_commit_tickets?.length > 0) {
                body += `### Note: Inherited Tickets\n\n`;
                body += `Tickets ${report.merge_commit_tickets.join(', ')} appear in the PR but have no commits on this branch. `;
                body += `They likely came from merging staging/main. Remove them from the Linear Tickets table.\n\n`;
              }

              if (report.spec_coverage) {
                body += `### Spec Coverage\n${report.spec_coverage}\n\n`;
              }

              body += `---\n<sub>Generated by [soc2-compliance](https://github.com/dorkalev/soc2-compliance)</sub>`;
            }

            // Find existing comment to update
            const { data: comments } = await github.rest.issues.listComments({
              owner: '${{ inputs.repo }}'.split('/')[0],
              repo: '${{ inputs.repo }}'.split('/')[1],
              issue_number: parseInt('${{ inputs.pr_number }}'),
            });

            const botComment = comments.find(c =>
              c.body.includes('SOC2 Compliance') &&
              c.body.includes('soc2-compliance')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: '${{ inputs.repo }}'.split('/')[0],
                repo: '${{ inputs.repo }}'.split('/')[1],
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: '${{ inputs.repo }}'.split('/')[0],
                repo: '${{ inputs.repo }}'.split('/')[1],
                issue_number: parseInt('${{ inputs.pr_number }}'),
                body: body
              });
            }

      - name: Upload compliance report artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: compliance-report-${{ inputs.pr_number }}
          path: compliance_report.json
          retention-days: 90

      - name: Fail if not compliant
        if: steps.check.outputs.compliant == 'false'
        run: |
          echo ""
          echo "============================================"
          echo "  SOC2 Compliance Check FAILED"
          echo "============================================"
          echo ""

          # Print summary
          SUMMARY=$(jq -r '.summary // "No summary"' compliance_report.json 2>/dev/null)
          echo "::error::$SUMMARY"
          echo ""

          # Print each violation category with details
          for field in issues invalid_tickets unimplemented_tickets unspecced_changes missing_documentation; do
            COUNT=$(jq -r ".$field | length" compliance_report.json 2>/dev/null || echo "0")
            if [ "$COUNT" != "0" ] && [ "$COUNT" != "null" ]; then
              LABEL=$(echo "$field" | tr '_' ' ' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) substr($i,2)}1')
              echo "::group::$LABEL ($COUNT)"
              jq -r ".$field[]" compliance_report.json 2>/dev/null | while IFS= read -r item; do
                echo "  - $item"
              done
              echo "::endgroup::"
            fi
          done

          # Print recommendations if any
          REC_COUNT=$(jq -r '.recommendations | length' compliance_report.json 2>/dev/null || echo "0")
          if [ "$REC_COUNT" != "0" ] && [ "$REC_COUNT" != "null" ]; then
            echo ""
            echo "Recommendations:"
            jq -r '.recommendations[]' compliance_report.json 2>/dev/null | while IFS= read -r rec; do
              echo "  â†’ $rec"
            done
          fi

          echo ""
          echo "Full report: see PR comment or download the compliance-report artifact."
          exit 1

name: SOC2 Compliance Check

on:
  workflow_call:
    inputs:
      pr_body:
        description: "Pull request body text"
        required: true
        type: string
      pr_number:
        description: "Pull request number"
        required: true
        type: string
      repo:
        description: "Repository being checked (owner/name)"
        required: true
        type: string
      base_branch:
        description: "Base branch to diff against"
        required: false
        type: string
        default: "main"
      ticket_pattern:
        description: "Regex pattern for ticket IDs (e.g., 'PROJ-[0-9]+')"
        required: true
        type: string
      issues_path:
        description: "Path to issue requirement files"
        required: false
        type: string
        default: "issues"
      specs_path:
        description: "Path to technical spec files"
        required: false
        type: string
        default: "specs"
      linear_team_id:
        description: "Linear team ID (optional, for Linear integration)"
        required: false
        type: string
      fail_on_unspecced:
        description: "Fail if changes are not covered by specs"
        required: false
        type: boolean
        default: true
      fail_on_missing_ticket:
        description: "Fail if no ticket is referenced in PR"
        required: false
        type: boolean
        default: true
    secrets:
      GEMINI_API_KEY:
        required: true
      LINEAR_API_KEY:
        required: false
      REPO_TOKEN:
        required: true
    outputs:
      compliant:
        description: "Whether the PR is compliant"
        value: ${{ jobs.verify.outputs.compliant }}
      report:
        description: "Compliance report JSON"
        value: ${{ jobs.verify.outputs.report }}

jobs:
  verify:
    runs-on: ubuntu-latest
    outputs:
      compliant: ${{ steps.check.outputs.compliant }}
      report: ${{ steps.check.outputs.report }}

    steps:
      - name: Checkout compliance tools
        uses: actions/checkout@v4
        with:
          repository: dorkalev/soc2-compliance

      - name: Checkout target repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          token: ${{ secrets.REPO_TOKEN }}
          path: ./target
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha || github.sha }}

      - name: Fetch base branch
        working-directory: ./target
        run: git fetch origin ${{ inputs.base_branch }}

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install dependencies
        run: pip install httpx google-genai

      - name: Run compliance check
        id: check
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          LINEAR_API_KEY: ${{ secrets.LINEAR_API_KEY }}
          PR_BODY: ${{ inputs.pr_body }}
          PR_NUMBER: ${{ inputs.pr_number }}
          TARGET_REPO: ./target
          BASE_BRANCH: ${{ inputs.base_branch }}
          TICKET_PATTERN: ${{ inputs.ticket_pattern }}
          ISSUES_PATH: ${{ inputs.issues_path }}
          SPECS_PATH: ${{ inputs.specs_path }}
          LINEAR_TEAM_ID: ${{ inputs.linear_team_id }}
          FAIL_ON_UNSPECCED: ${{ inputs.fail_on_unspecced }}
          FAIL_ON_MISSING_TICKET: ${{ inputs.fail_on_missing_ticket }}
        run: |
          # Run compliance check, capturing both stdout and exit code
          set +e
          python scripts/verify_compliance.py > compliance_report.json 2>&1
          EXIT_CODE=$?
          set -e

          # If script failed or output is empty, create error report
          if [ $EXIT_CODE -ne 0 ] || [ ! -s compliance_report.json ]; then
            echo "Script failed with exit code $EXIT_CODE"
            cat compliance_report.json || true
            echo '{"compliant": false, "summary": "Compliance check script failed", "issues": ["Script error - check workflow logs"], "tickets_found": []}' > compliance_report.json
          fi

          # Validate JSON
          if ! jq -e . compliance_report.json > /dev/null 2>&1; then
            echo "Invalid JSON in compliance_report.json:"
            cat compliance_report.json
            echo '{"compliant": false, "summary": "Invalid JSON output from compliance script", "issues": ["Script produced invalid JSON"], "tickets_found": []}' > compliance_report.json
          fi

          # Extract results for outputs
          COMPLIANT=$(jq -r '.compliant' compliance_report.json)
          echo "compliant=$COMPLIANT" >> $GITHUB_OUTPUT

          # Store full report (escape for GitHub Actions)
          REPORT=$(cat compliance_report.json | jq -c .)
          echo "report=$REPORT" >> $GITHUB_OUTPUT

      - name: Post comment to PR
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.REPO_TOKEN }}
          script: |
            const fs = require('fs');
            let report;
            try {
              const content = fs.readFileSync('compliance_report.json', 'utf8');
              if (!content || content.trim() === '') {
                throw new Error('compliance_report.json is empty');
              }
              report = JSON.parse(content);
            } catch (e) {
              console.error('Failed to parse compliance_report.json:', e.message);
              report = {
                compliant: false,
                summary: 'Failed to parse compliance report: ' + e.message,
                issues: ['Check workflow logs for details'],
                tickets_found: []
              };
            }

            const icon = report.compliant ? ':white_check_mark:' : ':x:';
            const status = report.compliant ? 'Passed' : 'Failed';

            let body = `## ${icon} SOC2 Compliance Check: ${status}\n\n`;
            body += `**Summary:** ${report.summary}\n\n`;

            if (report.tickets_found && report.tickets_found.length > 0) {
              body += `### Tickets Referenced\n`;
              report.tickets_found.forEach(t => {
                body += `- ${t}\n`;
              });
              body += '\n';
            }

            if (report.issues && report.issues.length > 0) {
              body += `### Issues Found\n`;
              report.issues.forEach(issue => {
                body += `- :warning: ${issue}\n`;
              });
              body += '\n';
            }

            // PR ‚Üí Linear: Invalid tickets
            if (report.invalid_tickets && report.invalid_tickets.length > 0) {
              body += `### :rotating_light: Invalid Tickets (PR ‚Üí Linear)\n`;
              body += `These tickets are listed in the PR but **do not exist in Linear**:\n\n`;
              report.invalid_tickets.forEach(t => {
                body += `- :x: \`${t}\`\n`;
              });
              body += '\n';
              body += `**Fix:** Remove these ticket IDs from the PR description or create them in Linear.\n\n`;
            }

            // Code ‚Üí PR: Unspecced changes
            if (report.unspecced_changes && report.unspecced_changes.length > 0) {
              body += `### :warning: Unspecced Changes (Code ‚Üí PR)\n`;
              body += `These code changes are **not documented** in the PR description:\n`;
              report.unspecced_changes.forEach(c => {
                body += `- \`${c}\`\n`;
              });
              body += '\n';

              // Add fix suggestions if available
              if (report.fix_suggestions) {
                const suggestions = report.fix_suggestions;

                body += `### :wrench: Suggested Fix\n\n`;
                body += `Add these entries to your PR's **Key Changes** table:\n\n`;

                body += `<details>\n<summary>üìù Click to expand suggested table rows</summary>\n\n`;
                body += `\`\`\`markdown\n`;
                body += `| File | Change | Ticket | Description |\n`;
                body += `|------|--------|--------|-------------|\n`;
                if (suggestions.suggested_table_rows) {
                  suggestions.suggested_table_rows.forEach(row => {
                    body += row + '\n';
                  });
                }
                body += `\`\`\`\n\n`;
                body += `</details>\n\n`;

                // Agent prompt
                body += `<details>\n<summary>ü§ñ Prompt for your coding agent (Claude Code, Cursor, etc.)</summary>\n\n`;
                body += `\`\`\`\n`;
                body += suggestions.agent_prompt || 'Add the unspecced files to the PR description Key Changes table.';
                body += `\n\`\`\`\n\n`;
                body += `</details>\n\n`;

                // Quick action hint
                body += `**Quick fix:** Copy the table rows above and add them to your PR description, or use the agent prompt.\n\n`;
              }
            }

            // PR ‚Üí Code: Unimplemented tickets
            if (report.unimplemented_tickets && report.unimplemented_tickets.length > 0) {
              body += `### :rotating_light: Unimplemented Tickets (PR ‚Üí Code)\n`;
              body += `These tickets are listed in the PR but have **NO corresponding code changes**:\n\n`;
              report.unimplemented_tickets.forEach(t => {
                body += `- :x: \`${t}\`\n`;
              });
              body += '\n';
              body += `**This is a compliance violation.** Either:\n`;
              body += `1. Remove these tickets from the PR description, OR\n`;
              body += `2. Implement the changes described in these tickets\n\n`;
              body += `<details>\n<summary>ü§ñ Prompt for your coding agent</summary>\n\n`;
              body += `\`\`\`\n`;
              body += `The SOC2 compliance check found tickets listed in the PR that have no code changes.\n`;
              body += `Please either:\n`;
              body += `1. Remove these tickets from the Linear Tickets table in the PR description\n`;
              body += `2. Or implement the changes required by these tickets\n`;
              body += `\n`;
              body += `Unimplemented tickets:\n`;
              report.unimplemented_tickets.forEach(t => {
                body += `- ${t}\n`;
              });
              body += `\`\`\`\n\n`;
              body += `</details>\n\n`;
            }

            // PR ‚Üí Issues/Specs: Missing documentation (warning only)
            if (report.missing_documentation && report.missing_documentation.length > 0) {
              body += `### :memo: Missing Documentation (PR ‚Üí Issues/Specs)\n`;
              body += `These tickets don't have corresponding documentation files:\n\n`;
              report.missing_documentation.forEach(t => {
                body += `- :warning: \`${t}\`\n`;
              });
              body += '\n';
              body += `Consider adding \`issues/{TICKET}.md\` and/or \`specs/{feature}.md\` files.\n\n`;
            }

            if (report.spec_coverage) {
              body += `### Spec Coverage\n`;
              body += `${report.spec_coverage}\n\n`;
            }

            body += `---\n`;
            body += `<sub>Generated by [soc2-compliance](https://github.com/dorkalev/soc2-compliance)</sub>`;

            // Find existing comment to update
            const { data: comments } = await github.rest.issues.listComments({
              owner: '${{ inputs.repo }}'.split('/')[0],
              repo: '${{ inputs.repo }}'.split('/')[1],
              issue_number: parseInt('${{ inputs.pr_number }}'),
            });

            const botComment = comments.find(c =>
              c.body.includes('SOC2 Compliance Check') &&
              c.body.includes('soc2-compliance')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: '${{ inputs.repo }}'.split('/')[0],
                repo: '${{ inputs.repo }}'.split('/')[1],
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: '${{ inputs.repo }}'.split('/')[0],
                repo: '${{ inputs.repo }}'.split('/')[1],
                issue_number: parseInt('${{ inputs.pr_number }}'),
                body: body
              });
            }

      - name: Fail if not compliant
        if: steps.check.outputs.compliant == 'false'
        run: |
          echo "::error::SOC2 Compliance check failed. See PR comment for details."
          exit 1
